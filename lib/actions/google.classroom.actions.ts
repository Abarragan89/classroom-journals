"use server"
import { GoogleClassroom, User } from "@/types";
import { getValidAccessToken } from "./refresh.token.action";
import { prisma } from "@/db/prisma";
import { decryptText, generateClassCode, generateRandom5DigitNumber } from "../utils";
import { GoogleProfile } from "next-auth/providers/google";
import { encryptText } from "../utils";
import crypto from 'crypto';
import { ClassUserRole, TeacherAccountType } from "@prisma/client";
import { requireAuth } from "./authorization.action";


// Get all Active google classroom classes that teacher is owner
export async function getTeacherGoogleClassrooms(googleProviderId: string) {
    const session = await requireAuth();
    if (session?.googleProviderId !== googleProviderId) {
        throw new Error('Forbidden');
    }
    const accessToken = await getValidAccessToken()
    try {
        const res = await fetch(
            `https://classroom.googleapis.com/v1/courses`,
            {
                headers: {
                    Authorization: `Bearer ${accessToken}`,
                },
            }
        );
        const data = await res.json();
        const currentClassrooms = data?.courses?.filter((currentClass: GoogleClassroom) => currentClass.courseState === 'ACTIVE' && currentClass.ownerId === googleProviderId)
        return currentClassrooms || [];

    } catch (error) {
        if (error instanceof Error) {
            console.error("Error fetching prompts:", error.message);
            console.error(error.stack);
        } else {
            console.error("Unexpected error:", error);
        }

        return { success: false, message: "Error fetching prompts. Try again." };
    }
}

// create class with google classroom roster
export async function createClassroomWithGoogle(classroom: GoogleClassroom, teacherId: string) {
    const session = await requireAuth();
    if (session?.user?.id !== teacherId) {
        throw new Error('Forbidden');
    }
    try {
        const accessToken = await getValidAccessToken()
        const res = await fetch(
            `https://classroom.googleapis.com/v1/courses/${classroom.id}/students`,
            {
                headers: {
                    Authorization: `Bearer ${accessToken}`,
                },
            }
        );
        if (!res.ok) {
            throw new Error(`Error fetching classrooms: ${res.statusText}`);
        }
        const studentdata = await res.json(); // this is coming from google classroom

        // get all classcodes so we don't have collisions
        const allClassCodes = await prisma.classroom.findMany({
            where: {},
            select: { classCode: true }
        })
        const classCodes = allClassCodes.map(classroom => classroom.classCode)
        const classCode = generateClassCode(classCodes);

        return await prisma.$transaction(async (prisma) => {
            const newClassroom = await prisma.classroom.create({
                data: {
                    name: classroom.name,
                    classCode: classCode,
                    color: '#dc2626',
                    subject: classroom?.section || 'N/A',
                    year: classroom?.creationTime?.split('-')[0] || 'N/A'
                }
            })

            // Create Teacher association
            await prisma.classUser.create({
                data: {
                    userId: teacherId,
                    classId: newClassroom.id,
                    role: ClassUserRole.TEACHER
                }
            })

            // If there are students in the roster, add them to the calss
            if (studentdata?.students?.length > 0) {
                const passwordsAlreadyInuse: string[] = [];

                const studentsToAdd = studentdata?.students?.map((student: GoogleProfile) => {
                    const iv = crypto.randomBytes(16); // Generate a random IV
                    const { encryptedData: encryptedName } = encryptText(student.profile.name.fullName, iv);
                    const { encryptedData: encryptedNickName } = encryptText(student.profile.name.fullName.split(' ')[0], iv);

                    // Make a password
                    const password = generateRandom5DigitNumber(passwordsAlreadyInuse);
                    passwordsAlreadyInuse.push(password);

                    // Encrypte password before setting to database
                    const { encryptedData: encryptedPassword } = encryptText(password, iv);
                    // include the newly created password in the exclude array for next iteration

                    return {
                        googleId: student.profile.id, // This will just be their googleId, actual ID is autogenerated
                        name: encryptedName, // Store the encrypted name
                        username: encryptedNickName,
                        iv: iv.toString('hex'), // Store the IV (Initialization Vector) used for encryption
                        password: encryptedPassword,
                        commentCoolDown: 20,
                        accountType: TeacherAccountType.BASIC
                    };
                });

                const addedStudents = await Promise.all(
                    // I need to omit accountType to avoid typescript error becuase it infers accountType as string | undefined
                    studentsToAdd.map((student: Omit<User, 'accountType'>) =>
                        prisma.user.upsert({
                            where: { googleId: student.googleId }, // Ensure uniqueness using email
                            update: {}, // If the student exists, do nothing
                            create: student, // Otherwise, create the student
                        })
                    )
                );

                // Generate the associations with students and classroom
                const classUserAssociations = addedStudents?.map((student: User) => ({
                    userId: student.id, // Use the `userId` returned from the user table
                    classId: newClassroom.id,
                    role: ClassUserRole.STUDENT
                }));


                // Make Classroom associations
                await prisma.classUser.createMany({
                    data: classUserAssociations,
                    skipDuplicates: true
                })
            }
            return newClassroom
        }, { timeout: 20000 })

    } catch (error) {
        if (error instanceof Error) {
            console.error("Error fetching prompts:", error.message);
            console.error(error.stack);
        } else {
            console.error("Unexpected error:", error);
        }

        return { success: false, message: "Error fetching prompts. Try again." };
    }
}

// Add to Roster from google classroom
export async function populateStudentRosterFromGoogle(classroom: GoogleClassroom, teacherId: string, classId: string) {
    try {
        const session = await requireAuth();
        if (session?.user?.id !== teacherId) {
            throw new Error('Forbidden');
        }
        const accessToken = await getValidAccessToken()
        const res = await fetch(
            `https://classroom.googleapis.com/v1/courses/${classroom.id}/students`,
            {
                headers: {
                    Authorization: `Bearer ${accessToken}`,
                },
            }
        );
        if (!res.ok) {
            throw new Error(`Error fetching classrooms: ${res.statusText}`);
        }
        const studentdata = await res.json(); // this is coming from google classroom

        // let result: User[] | null = null;
        const result = await prisma.$transaction(async (prisma) => {

            // Get existing students by googleId in one query
            const existingStudents = await prisma.user.findMany({
                where: {
                    googleId: {
                        in: studentdata?.students?.map((s: GoogleProfile) => s.profile.id),
                    },
                },
                select: {
                    googleId: true,
                    password: true,
                    iv: true
                },
            });

            const existingStudentIds = new Set(existingStudents.map((s) => s.googleId));
            const existingPasswords = existingStudents.map((stud) => {
                return decryptText(stud?.password as string, stud?.iv as string)
            })

            // Filter students who arenâ€™t already in the database
            const newStudents = studentdata?.students?.filter(
                (student: GoogleProfile) => !existingStudentIds.has(student.profile.id)
            );

            const studentsToAdd = newStudents?.map((student: GoogleProfile) => {
                const iv = crypto.randomBytes(16); // Generate a random IV
                const { encryptedData: encryptedName } = encryptText(student.profile.name.fullName, iv);
                const { encryptedData: encryptedNickName } = encryptText(student.profile.name.fullName.split(' ')[0], iv);
                // Make a password
                const password = generateRandom5DigitNumber(existingPasswords)
                // include the newly created password in the exclude array for next iteration
                existingPasswords.push(password)

                const { encryptedData: encryptedPassword } = encryptText(password, iv);

                return {
                    googleId: student.profile.id, // This will just be their googleId, actual ID is autogenerated
                    name: encryptedName, // Store the encrypted name
                    username: encryptedNickName,
                    iv: iv.toString('hex'), // Store the IV (Initialization Vector) used for encryption
                    password: encryptedPassword,
                    commentCoolDown: 20
                };
            });


            // Create only new students, skipping duplicates
            if (studentsToAdd?.length > 0) {
                await prisma.user.createMany({
                    data: studentsToAdd,
                    skipDuplicates: true,
                });
            }

            // Fetch the students again to ensure you have all IDs (existing + newly added)
            const allStudents = await prisma.user.findMany({
                where: {
                    googleId: {
                        in: studentdata?.students?.map((s: GoogleProfile) => s.profile.id),
                    },
                },
                select: { id: true, googleId: true },
            });

            // Generate associations with students and classroom
            const classUserAssociations = allStudents.map((student) => ({
                userId: student.id,
                classId: classId,
                role: ClassUserRole.STUDENT
            }));

            // Make Classroom associations, skipping duplicates
            if (classUserAssociations?.length > 0) {
                await prisma.classUser.createMany({
                    data: classUserAssociations,
                    skipDuplicates: true,
                });
            }


            // Return all the students in classroom to send back and update the client
            const finalStudentsInClass = await prisma.classUser.findMany({
                where: {
                    classId: classId,
                    role: ClassUserRole.STUDENT
                },
                select: {
                    user: {
                        select: {
                            id: true,
                            name: true,
                            iv: true,
                            username: true,
                            password: true,
                        }
                    }
                }
            });

            const decryptedStudents = finalStudentsInClass
                .filter(studentObj => studentObj.user) // Ensure user exists
                .map(({ user }) => ({ // Destructure `user` from `studentObj`
                    id: user.id,
                    username: decryptText(user.username as string, user.iv as string),
                    password: decryptText(user.password as string, user.iv as string),
                    name: decryptText(user.name as string, user.iv as string) // Decrypt name
                }));

            return { success: true, message: "Successfully added students.", data: decryptedStudents };
        }, { timeout: 20000 })
        return { success: true, message: "Successfully added students.", data: result };
    } catch (error) {
        if (error instanceof Error) {
            console.error("Error fetching prompts:", error.message);
            console.error(error.stack);
        } else {
            console.error("Unexpected error:", error);
        }
        return { success: false, message: "Error fetching prompts. Try again.", data: null };
    }
}