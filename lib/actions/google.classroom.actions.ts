"use server"
import { GoogleClassroom, User } from "@/types";
import { getValidAccessToken } from "./refresh.token.action";
import { prisma } from "@/db/prisma";
import { generateClassCode, generateRandom5DigitNumber } from "../utils";
import { GoogleProfile } from "next-auth/providers/google";
import { encryptText } from "../utils";
import crypto from 'crypto';


// Get all Active google classroom classes that teacher is owner
export async function getTeacherGoogleClassrooms(googleProviderId: string) {
    const accessToken = await getValidAccessToken()
    try {
        const res = await fetch(
            `https://classroom.googleapis.com/v1/courses`,
            {
                headers: {
                    Authorization: `Bearer ${accessToken}`,
                },
            }
        );
        const data = await res.json();
        const currentClassrooms = data?.courses?.filter((currentClass: GoogleClassroom) => currentClass.courseState === 'ACTIVE' && currentClass.ownerId === googleProviderId)
        return currentClassrooms || [];

    } catch (error) {
        if (error instanceof Error) {
            console.log("Error fetching prompts:", error.message);
            console.error(error.stack);
        } else {
            console.log("Unexpected error:", error);
        }

        return { success: false, message: "Error fetching prompts. Try again." };
    }
}

// create class with google classroom roster
export async function createClassroomWithGoogle(classroom: GoogleClassroom, teacherId: string) {

    try {
        const accessToken = await getValidAccessToken()
        const res = await fetch(
            `https://classroom.googleapis.com/v1/courses/${classroom.id}/students`,
            {
                headers: {
                    Authorization: `Bearer ${accessToken}`,
                },
            }
        );
        if (!res.ok) {
            throw new Error(`Error fetching classrooms: ${res.statusText}`);
        }
        const studentdata = await res.json(); // this is coming from google classroom

        // get all classcodes so we don't have collisions
        const allClassCodes = await prisma.classroom.findMany({
            where: {},
            select: { classCode: true }
        })
        const classCodes = allClassCodes.map(classroom => classroom.classCode)
        const classCode = generateClassCode(classCodes);

        let classroomId: string = '';
        await prisma.$transaction(async (prisma) => {
            const newClassroom = await prisma.classroom.create({
                data: {
                    name: classroom.name,
                    classCode: classCode,
                    color: '#dc2626',
                    subject: classroom?.section || 'N/A',
                    year: classroom?.creationTime?.split('-')[0] || 'N/A'
                }
            })

            // Create Teacher association
            await prisma.classUser.create({
                data: {
                    userId: teacherId,
                    classId: newClassroom.id,
                    role: 'teacher'
                }
            })

            // If there are students in the roster, add them to the calss
            if (studentdata?.students?.length > 0) {
                const passwordsAlreadyInuse: string[] = [];

                const studentsToAdd = studentdata?.students?.map((student: GoogleProfile) => {
                    const iv = crypto.randomBytes(16); // Generate a random IV
                    const { encryptedData: encryptedName } = encryptText(student.profile.name.fullName, iv);
                    const { encryptedData: encryptedNickName } = encryptText(student.profile.name.fullName.split(' ')[0], iv);
                    // Make a password
                    const password = generateRandom5DigitNumber(passwordsAlreadyInuse)
                    // include the newly created password in the exclude array for next iteration
                    passwordsAlreadyInuse.push(password)
                    return {
                        googleId: student.profile.id, // This will just be their googleId, actual ID is autogenerated
                        name: encryptedName, // Store the encrypted name
                        username: encryptedNickName,
                        iv: iv.toString('hex'), // Store the IV (Initialization Vector) used for encryption
                        password,
                        commentCoolDown: 20
                    };
                });

                const addedStudents = await Promise.all(
                    studentsToAdd.map((student: User) =>
                        prisma.user.upsert({
                            where: { googleId: student.googleId }, // Ensure uniqueness using email
                            update: {}, // If the student exists, do nothing
                            create: student, // Otherwise, create the student
                        })
                    )
                );

                // Generate the associations with students and classroom
                const classUserAssociations = addedStudents?.map((student: User) => ({
                    userId: student.id, // Use the `userId` returned from the user table
                    classId: newClassroom.id,
                    role: 'student',
                }));


                // Make Classroom associations
                await prisma.classUser.createMany({
                    data: classUserAssociations,
                    skipDuplicates: true
                })
            }
            classroomId = newClassroom.id
            return newClassroom.id
        }, { timeout: 20000 })
        return classroomId

    } catch (error) {
        if (error instanceof Error) {
            console.log("Error fetching prompts:", error.message);
            // // console.error(error.stack);
        } else {
            console.log("Unexpected error:", error);
        }

        return { success: false, message: "Error fetching prompts. Try again." };
    }
}


// Add to Roster from google classroom
export async function populateStudentRosterFromGoogle(classroom: GoogleClassroom, teacherId: string, classId: string) {
    try {
        const accessToken = await getValidAccessToken()
        const res = await fetch(
            `https://classroom.googleapis.com/v1/courses/${classroom.id}/students`,
            {
                headers: {
                    Authorization: `Bearer ${accessToken}`,
                },
            }
        );
        if (!res.ok) {
            throw new Error(`Error fetching classrooms: ${res.statusText}`);
        }
        const studentdata = await res.json(); // this is coming from google classroom

        await prisma.$transaction(async (prisma) => {

            // Get existing students by googleId in one query
            const existingStudents = await prisma.user.findMany({
                where: {
                    googleId: {
                        in: studentdata?.students?.map((s: GoogleProfile) => s.profile.id),
                    },
                },
                select: { googleId: true },
            });

            const existingStudentIds = new Set(existingStudents.map((s) => s.googleId));

            // Filter students who arenâ€™t already in the database
            const newStudents = studentdata?.students?.filter(
                (student: GoogleProfile) => !existingStudentIds.has(student.profile.id)
            );

            const passwordsAlreadyInuse: string[] = [];

            const studentsToAdd = newStudents?.map((student: GoogleProfile) => {
                const iv = crypto.randomBytes(16); // Generate a random IV
                const { encryptedData: encryptedName } = encryptText(student.profile.name.fullName, iv);
                const { encryptedData: encryptedNickName } = encryptText(student.profile.name.fullName.split(' ')[0], iv);
                // Make a password
                const password = generateRandom5DigitNumber(passwordsAlreadyInuse)
                // include the newly created password in the exclude array for next iteration
                passwordsAlreadyInuse.push(password)
                return {
                    googleId: student.profile.id, // This will just be their googleId, actual ID is autogenerated
                    name: encryptedName, // Store the encrypted name
                    username: encryptedNickName,
                    iv: iv.toString('hex'), // Store the IV (Initialization Vector) used for encryption
                    password,
                    commentCoolDown: 20
                };
            });

            // Create only new students, skipping duplicates
            if (studentsToAdd?.length > 0) {
                await prisma.user.createMany({
                    data: studentsToAdd,
                    skipDuplicates: true,
                });
            }

            // Fetch the students again to ensure you have all IDs (existing + newly added)
            const allStudents = await prisma.user.findMany({
                where: {
                    googleId: {
                        in: studentdata?.students?.map((s: GoogleProfile) => s.profile.id),
                    },
                },
                select: { id: true, googleId: true },
            });

            // Generate associations with students and classroom
            const classUserAssociations = allStudents.map((student) => ({
                userId: student.id,
                classId: classId,
                role: "student",
            }));

            // Make Classroom associations, skipping duplicates
            if (classUserAssociations?.length > 0) {
                await prisma.classUser.createMany({
                    data: classUserAssociations,
                    skipDuplicates: true,
                });
            }
            return { success: true, message: "Successfully added students." }
        },
            { timeout: 20000 })
        return { success: true, message: "Successfully added students." }
    } catch (error) {
        if (error instanceof Error) {
            console.log("Error fetching prompts:", error.message);
            console.error(error.stack);
        } else {
            console.log("Unexpected error:", error);
        }
        return { success: false, message: "Error fetching prompts. Try again." };
    }
}