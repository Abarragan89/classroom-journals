generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["driverAdapters"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum TeacherAccountType {
  BASIC
  STANDARD
  PREMIUM
  TRIAL
}

model User {
  id                  String             @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  googleId            String?            @unique // Optional, only for students with Google IDs
  name                String?            @default("NO_NAME")
  username            String?
  email               String?            @unique(map: "user_email_idx")
  emailVerified       DateTime?          @db.Timestamp(6)
  image               String?
  isAdmin             Boolean            @default(false)
  wpmSpeed            Float              @default(0.0)
  avatarURL           String?
  accountType         TeacherAccountType @default(BASIC)
  password            String? // this password is only for student accounts and needs to be accessible to teacher
  iv                  String? // this is used to encrypt student names, ensures no duplicates when same input is given when encrypting
  sessions            Session[]
  accounts            Account[]
  createdAt           DateTime           @default(now()) @db.Timestamp(6)
  updatedAt           DateTime           @updatedAt
  comments            Comment[]
  responseLikes       ResponseLike[]
  commentLikes        CommentLike[]
  responses           Response[]
  notifications       Notification[]
  classes             ClassUser[]
  requestsSent        StudentRequest[]   @relation("RequestsByStudent")
  requestsReceived    StudentRequest[]   @relation("RequestsToTeacher")
  // These are only related to Students
  commentCoolDown     Int?               @default(0)
  // These are only related to Teachers
  prompts             Prompt[] // Prompts are for teachers
  PromptCategory      PromptCategory[]
  customerId          String?
  subscriptionId      String?
  isCancelling        Boolean?
  subscriptionExpires DateTime?
  openAIAllowance     Int?               @default(50)
  purchasedCredits    Int                @default(0)
  Alert               Alert[]
  PromptSession       PromptSession[]
  rubricTemplates     RubricTemplate[]
  rubricGrades        RubricGrade[] // Grades given by this teacher
}

model Account {
  userId            String   @db.Uuid
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  createdAt         DateTime @default(now()) @db.Timestamp(6)
  updatedAt         DateTime @updatedAt
  user              User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([provider, providerAccountId])
}

model Session {
  sessionToken String   @id
  userId       String   @db.Uuid
  expires      DateTime @default(now()) @db.Timestamp(6)
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt    DateTime @default(now()) @db.Timestamp(6)
  updatedAt    DateTime @updatedAt
}

model VerificationToken {
  identifier String
  token      String
  expires    DateTime

  @@id([identifier, token])
}

model Classroom {
  id            String          @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  name          String
  classCode     String          @unique @db.VarChar(8)
  color         String
  subject       String?
  grade         String?
  year          String?         @db.VarChar(12)
  period        String?
  users         ClassUser[] // Many-to-many relationship(can be a teacher role or student rol)
  createdAt     DateTime        @default(now()) @db.Timestamp(6)
  updatedAt     DateTime        @default(now()) @updatedAt @db.Timestamp(6)
  PromptSession PromptSession[]
}

enum ClassUserRole {
  TEACHER
  STUDENT
}

model ClassUser {
  userId  String        @db.Uuid
  classId String        @db.Uuid
  role    ClassUserRole @default(STUDENT)
  user    User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  class   Classroom     @relation(fields: [classId], references: [id], onDelete: Cascade)

  @@id([userId, classId]) // Composite primary key
  @@index([userId, role]) // For faster search ups
  @@index([classId, role])
}

model Notification {
  id          String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  userId      String   @db.Uuid
  responseId  String   @db.Uuid
  classId     String   @db.Uuid
  url         String
  message     String
  commentText String?
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  response    Response @relation(fields: [responseId], references: [id], onDelete: Cascade)
  createdAt   DateTime @default(now())
  isRead      Boolean  @default(false)

  @@index([userId, isRead, classId])
}

// This is used for teachers when payment fails

enum AlertType {
  PAYMENT
  NEWQUIP
}

model Alert {
  id        String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  userId    String    @db.Uuid
  type      AlertType
  message   String
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt DateTime  @default(now())
  isRead    Boolean   @default(false)

  @@index([userId, type])
}

model Comment {
  id         String        @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  text       String        @db.VarChar(1000)
  likeCount  Int           @default(0)
  likes      CommentLike[]
  createdAt  DateTime      @default(now())
  userId     String        @db.Uuid
  responseId String        @db.Uuid
  parentId   String?       @db.Uuid // Null for top-level comments; set for replies
  user       User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  response   Response      @relation(fields: [responseId], references: [id], onDelete: Cascade)
  parent     Comment?      @relation("CommentReplies", fields: [parentId], references: [id])
  replies    Comment[]     @relation("CommentReplies")

  @@index([parentId]) // Optional: Improves performance when querying replies
  @@index([responseId])
}

model ResponseLike {
  id         String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  userId     String   @db.Uuid
  responseId String   @db.Uuid
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  response   Response @relation(fields: [responseId], references: [id], onDelete: Cascade)
  createdAt  DateTime @default(now())

  @@unique([userId, responseId]) // Ensure a user can like a response only once
}

model CommentLike {
  id        String  @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  userId    String  @db.Uuid
  commentId String  @db.Uuid
  user      User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  comment   Comment @relation(fields: [commentId], references: [id], onDelete: Cascade)

  @@unique([userId, commentId]) // Ensure a user can like a resoponse only once
}

enum PromptType {
  BLOG
  ASSESSMENT
  QUIP
}

model Prompt {
  id            String          @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  title         String
  teacherId     String          @db.Uuid
  promptType    PromptType
  teacher       User            @relation(fields: [teacherId], references: [id], onDelete: Cascade)
  createdAt     DateTime        @default(now())
  updatedAt     DateTime        @updatedAt
  author        String?
  questions     Json
  promptSession PromptSession[]
  categoryId    String?         @db.Uuid
  category      PromptCategory? @relation(fields: [categoryId], references: [id], onDelete: SetNull) // Each prompt has one category
}

model PromptCategory {
  id      String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  name    String
  userId  String   @db.Uuid
  user    User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  prompts Prompt[]
}

enum PromptSessionStatus {
  OPEN
  CLOSED
}

model PromptSession {
  id               String              @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  promptId         String?             @db.Uuid
  title            String
  questions        Json // Single array of question objects
  promptType       PromptType
  isPublic         Boolean             @default(true)
  assignedAt       DateTime            @default(now())
  areGradesVisible Boolean             @default(false)
  classId          String              @db.Uuid // relate it to which side it is attached to
  status           PromptSessionStatus @default(OPEN) // Can be open or closed for comments
  responses        Response[]
  // This is mainly for threads when a student suggests a thread and it is accepted
  authorId         String?             @db.Uuid
  // Relationship
  author           User?               @relation(fields: [authorId], references: [id], onDelete: SetNull)
  prompt           Prompt?             @relation(fields: [promptId], references: [id], onDelete: SetNull)
  class            Classroom           @relation(fields: [classId], references: [id], onDelete: Cascade)
  createdAt        DateTime            @default(now())
  updatedAt        DateTime            @updatedAt

  @@index([classId, promptType])
}

enum ResponseStatus {
  INCOMPLETE
  COMPLETE
  RETURNED
}

model Response {
  id                   String         @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  promptSessionId      String         @db.Uuid
  studentId            String         @db.Uuid
  spellCheckEnabled    Boolean        @default(false)
  isVoiceToTextEnabled Boolean        @default(false)
  response             Json //stores questions, answers, and score (score is Correct, 1/2 or wrong) Arrary of objects
  submittedAt          DateTime? // Nullable in case they haven't submitted yet
  completionStatus     ResponseStatus @default(INCOMPLETE)
  likeCount            Int            @default(0)
  likes                ResponseLike[]
  notifications        Notification[]
  comments             Comment[]
  rubricGrades         RubricGrade[] // Rubric grades for this response
  createdAt            DateTime       @default(now())
  // Relationship
  promptSession        PromptSession  @relation(fields: [promptSessionId], references: [id], onDelete: Cascade)
  student              User           @relation(fields: [studentId], references: [id], onDelete: Cascade)

  @@index([studentId, completionStatus])
  @@index([promptSessionId])
}

enum StudentRequestStatus {
  PENDING
  VIEWED
}

enum StudentRequestType {
  USERNAME
  PROMPT
}

model StudentRequest {
  id        String               @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  studentId String               @db.Uuid
  teacherId String               @db.Uuid
  classId   String               @db.Uuid
  status    StudentRequestStatus // 'pending' || 'viewed' to let the notification show or not show
  type      StudentRequestType // 'username' || 'prompt'
  text      String
  createdAt DateTime             @default(now()) @db.Timestamp(6)

  // Relations
  student User @relation("RequestsByStudent", fields: [studentId], references: [id], onDelete: Cascade)
  teacher User @relation("RequestsToTeacher", fields: [teacherId], references: [id], onDelete: Cascade)

  @@index([teacherId, classId, status])
  @@index([studentId])
}

model Image {
  id        String   @id @default(cuid())
  url       String   @unique
  category  String
  tags      String[] // searchable tags
  createdAt DateTime @default(now())
}

// Rubric Model
model RubricTemplate {
  id         String        @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  title      String
  categories Json // JSON object containing the rubric structure
  teacherId  String        @db.Uuid
  teacher    User          @relation(fields: [teacherId], references: [id], onDelete: Cascade)
  grades     RubricGrade[] // Relation to actual grades using this rubric
  createdAt  DateTime      @default(now())
  updatedAt  DateTime      @updatedAt
}

// Model to store actual rubric grades for student responses
model RubricGrade {
  id              String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  responseId      String   @db.Uuid
  rubricId        String   @db.Uuid
  teacherId       String   @db.Uuid
  categories      Json // JSON array of category grades: {name, selectedScore, maxScore}
  totalScore      Int // Sum of all selected scores
  maxTotalScore   Int // Sum of all max scores
  percentageScore Int // Calculated percentage (totalScore/maxTotalScore * 100)
  comment         String? // Optional comment from teacher
  gradedAt        DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relations
  response Response       @relation(fields: [responseId], references: [id], onDelete: Cascade)
  rubric   RubricTemplate @relation(fields: [rubricId], references: [id], onDelete: Cascade)
  teacher  User           @relation(fields: [teacherId], references: [id], onDelete: Cascade)

  @@unique([responseId, rubricId]) // Ensure one grade per response per rubric
  @@index([responseId]) // Index for faster lookups by response
  @@index([teacherId]) // Index for faster lookups by teacher
}
